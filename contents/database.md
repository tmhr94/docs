<!--
本以外での参考となったもの

# ナイーブツリー
https://nomuyoshi0111.hatenablog.com/entry/2018/12/30/161703
https://techracho.bpsinc.jp/hira/2018_03_15/53872
https://qiita.com/yuyasat/items/1200d7a6b56bae0c6f57
https://qiita.com/bubu_suke/items/131b2eb7df9b16e5e3e5
-->

### インデックス
基本、カーディナリティが高いものにインデックスを貼る。また、複合インデックスに関しては、MySQLの場合オプティマイザがあるのでインデックスを貼っておけば効率の良いものを選択してくれる。有効測定はEXPLAINで問い合わせする。

### 負荷対応
#### 高トラフィック
リードレプリカにて対応。マスターはCRUD可能とし、スレーブ(レプリケーションされた側)はRオンリーとする。

#### 大量レコードへのクエリ
パーティション分割にて対応。キーを事前に選定する必要あり。
<!-- ここも書こう。 https://www.e-xtreme.co.jp/topics/3387/ -->

### SQLアンチパターン
本以外での参考先:
- https://nomuyoshi0111.hatenablog.com/entry/2018/12/30/161703

#### ジェイウォーク(信号無視)
参照する他テーブルに対するIDなどの情報をカラムにカンマ区切りで格納する。

##### 問題点
1. IDがインクリメントしていくにつれ、カラムに格納できる値が少なくなっていき、いずれ格納できなくなる。
1. データ整合性の問題が出る。(削除したはずのレコードへの参照が残る。)
1. 格納する値に区切り文字(カンマ等)が指定できなくなる。

##### 解決策
交差テーブル(中間テーブル)を作る。

例:

|  id  |  user_id  | post_id |
| ---- | ---- | ---- |
|  1  |  1  | 1 |
|  2  |  2  | 2 |

#### ナイーブツリー(自己参照型テーブル構造)
階層構造となるテーブルにおいて、 `parent_id` を用い実現する。(隣接リスト)

##### 問題点
1. 全ての子孫を取得する場合に対応することが出来ない。子孫は無限に続くことができるため、SQLのJOINで数を指定出来ない。(※親と子のみなど階層が限定されている場合は問題ない)

##### 解決策

以下3つのアプローチがある。

###### SQLの再帰クエリ
これはSQLで再帰を扱うためのクエリがあり、これを扱うことで問題を解決できる。ただし、各種DBにて対応していないバージョンがあるので注意。

###### 経路列挙
階層構造を `path` のようなカラムに `1/5/7/8` のような親以上のIDを格納する。
